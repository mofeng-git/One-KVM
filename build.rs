use std::fs;
use std::path::Path;

fn main() {
    // Set BUILD_DATE environment variable for compile-time access
    // Use system time to avoid adding chrono as a build dependency
    let now = std::time::SystemTime::now();
    let duration = now.duration_since(std::time::UNIX_EPOCH).unwrap();
    let secs = duration.as_secs();

    // Convert Unix timestamp to date (simplified calculation)
    // Days since epoch
    let days = secs / 86400;
    // Calculate year, month, day from days since 1970-01-01
    let (year, month, day) = days_to_ymd(days as i64);
    let build_date = format!("{:04}-{:02}-{:02}", year, month, day);

    println!("cargo:rustc-env=BUILD_DATE={}", build_date);

    // Compile protobuf files for RustDesk protocol
    compile_protos();

    // Generate secrets module from secrets.toml
    generate_secrets();

    // Rerun if the script itself changes
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=protos/rendezvous.proto");
    println!("cargo:rerun-if-changed=protos/message.proto");
    println!("cargo:rerun-if-changed=secrets.toml");
}

/// Compile protobuf files using prost-build
fn compile_protos() {
    let out_dir = std::path::PathBuf::from(std::env::var("OUT_DIR").unwrap());

    prost_build::Config::new()
        .out_dir(&out_dir)
        // Use bytes::Bytes for video/audio frame data to enable zero-copy
        .bytes([
            "EncodedVideoFrame.data",
            "AudioFrame.data",
            "CursorData.colors",
        ])
        .compile_protos(
            &["protos/rendezvous.proto", "protos/message.proto"],
            &["protos/"],
        )
        .expect("Failed to compile protobuf files");
}

/// Generate secrets module from secrets.toml
///
/// This reads the secrets.toml file and generates a Rust module with
/// compile-time constants for sensitive configuration values.
fn generate_secrets() {
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("secrets_generated.rs");

    // Default values if secrets.toml doesn't exist
    let mut rustdesk_public_server = String::new();
    let mut rustdesk_public_key = String::new();
    let mut turn_server = String::new();
    let mut turn_username = String::new();
    let mut turn_password = String::new();

    // Try to read secrets.toml
    if let Ok(content) = fs::read_to_string("secrets.toml") {
        if let Ok(value) = content.parse::<toml::Value>() {
            // RustDesk section
            if let Some(rustdesk) = value.get("rustdesk") {
                if let Some(v) = rustdesk.get("public_server").and_then(|v| v.as_str()) {
                    rustdesk_public_server = v.to_string();
                }
                if let Some(v) = rustdesk.get("public_key").and_then(|v| v.as_str()) {
                    rustdesk_public_key = v.to_string();
                }
            }

            // TURN section (for future use)
            if let Some(turn) = value.get("turn") {
                if let Some(v) = turn.get("server").and_then(|v| v.as_str()) {
                    turn_server = v.to_string();
                }
                if let Some(v) = turn.get("username").and_then(|v| v.as_str()) {
                    turn_username = v.to_string();
                }
                if let Some(v) = turn.get("password").and_then(|v| v.as_str()) {
                    turn_password = v.to_string();
                }
            }
        } else {
            println!("cargo:warning=Failed to parse secrets.toml");
        }
    } else {
        println!("cargo:warning=secrets.toml not found, using empty defaults");
    }

    // Generate the secrets module
    let code = format!(
        r#"// Auto-generated secrets module
// DO NOT EDIT - This file is generated by build.rs from secrets.toml

/// RustDesk public server configuration
pub mod rustdesk {{
    /// Public RustDesk ID server address (used when user leaves field empty)
    pub const PUBLIC_SERVER: &str = "{}";

    /// Public key for the RustDesk server (for client connection)
    pub const PUBLIC_KEY: &str = "{}";

    /// Check if public server is configured
    pub const fn has_public_server() -> bool {{
        !PUBLIC_SERVER.is_empty()
    }}
}}

/// TURN server configuration (for WebRTC)
pub mod turn {{
    /// TURN server address
    pub const SERVER: &str = "{}";

    /// TURN username
    pub const USERNAME: &str = "{}";

    /// TURN password
    pub const PASSWORD: &str = "{}";

    /// Check if TURN server is configured
    pub const fn is_configured() -> bool {{
        !SERVER.is_empty()
    }}
}}
"#,
        escape_string(&rustdesk_public_server),
        escape_string(&rustdesk_public_key),
        escape_string(&turn_server),
        escape_string(&turn_username),
        escape_string(&turn_password),
    );

    fs::write(&dest_path, code).expect("Failed to write secrets_generated.rs");
}

/// Escape special characters in a string for use in Rust string literals
fn escape_string(s: &str) -> String {
    s.replace('\\', "\\\\").replace('"', "\\\"")
}

/// Convert days since Unix epoch to year-month-day
fn days_to_ymd(days: i64) -> (i32, u32, u32) {
    // Algorithm from http://howardhinnant.github.io/date_algorithms.html
    let z = days + 719468;
    let era = if z >= 0 { z } else { z - 146096 } / 146097;
    let doe = (z - era * 146097) as u32;
    let yoe = (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365;
    let y = yoe as i64 + era * 400;
    let doy = doe - (365 * yoe + yoe / 4 - yoe / 100);
    let mp = (5 * doy + 2) / 153;
    let d = doy - (153 * mp + 2) / 5 + 1;
    let m = if mp < 10 { mp + 3 } else { mp - 9 };
    let year = if m <= 2 { y + 1 } else { y };
    (year as i32, m, d)
}
